
/* -------------------------------------------------------------------------
 * !!! AUTOMATICALLY GENERATED CODE !!!
 * -------------------------------------------------------------------------
 * This file was automatically generated by the OrangeBits compiler.  
 * Compiled on:  11/15/2012 9:17:52 PM
 * Compiled by: vestben-PC\vestben
 * Source: C:\Users\vestben\Documents\GitHub\cats-vs-codez\game\Map.coffee      
 * -------------------------------------------------------------------------*/


var Map;

Map = (function() {

  Map.branchs = {
    "mainBranch": {
      "color": "red",
      "activeWave": 3,
      "lines": [
        {
          x: 0,
          y: 6,
          x2: 17,
          y2: 6
        }
      ]
    },
    "secondaryBranch": {
      "color": "blue",
      "activeWave": 1,
      "lines": [
        {
          x: 0,
          y: 13,
          x2: 7,
          y2: 13
        }, {
          x: 7,
          y: 13,
          x2: 7,
          y2: 5
        }, {
          x: 7,
          y: 5,
          x2: 17,
          y2: 5
        }
      ]
    },
    "anotherBranch": {
      "color": "orange",
      "activeWave": 2,
      "lines": [
        {
          x: 0,
          y: 2,
          x2: 17,
          y2: 2
        }
      ]
    },
    "reallyWeirdBranch": {
      "color": "grey",
      "activeWave": 0,
      "lines": [
        {
          x: 0,
          y: 3,
          x2: 3,
          y2: 3
        }, {
          x: 3,
          y: 4,
          x2: 3,
          y2: 5
        }, {
          x: 3,
          y: 5,
          x2: 2,
          y2: 5
        }, {
          x: 2,
          y: 5,
          x2: 2,
          y2: 8
        }, {
          x: 2,
          y: 8,
          x2: 10,
          y2: 8
        }, {
          x: 10,
          y: 8,
          x2: 10,
          y2: 12
        }, {
          x: 10,
          y: 12,
          x2: 17,
          y2: 12
        }
      ]
    }
  };

  function Map(gridSize, movingCube) {
    this.gridSize = gridSize;
    this.movingCube = movingCube;
    this.fillGrid();
    this.direction = {
      x: 0.1,
      y: 0
    };
    this.theLine = 0;
  }

  Map.prototype.drawGrid = function() {
    var horizontalLines, verticalLines, _results;
    horizontalLines = 0;
    verticalLines = 0;
    while (horizontalLines <= this.gridSize.y + 1) {
      g.setStrokeStyle(1).beginStroke("black").moveTo(0, horizontalLines * 50).lineTo((this.gridSize.x + 1) * 50, horizontalLines * 50);
      horizontalLines += 1;
    }
    _results = [];
    while (verticalLines <= this.gridSize.x + 1) {
      g.setStrokeStyle(1).beginStroke("black").moveTo(verticalLines * 50, 0).lineTo(verticalLines * 50, (this.gridSize.y + 1) * 50);
      _results.push(verticalLines += 1);
    }
    return _results;
  };

  Map.prototype.fillGrid = function() {
    var i, j, _ref, _results;
    _results = [];
    for (i = 0, _ref = this.gridSize.x; 0 <= _ref ? i <= _ref : i >= _ref; 0 <= _ref ? i++ : i--) {
      towerGrid[i] = new Array();
      _results.push((function() {
        var _ref2, _results2;
        _results2 = [];
        for (j = 0, _ref2 = this.gridSize.y; 0 <= _ref2 ? j <= _ref2 : j >= _ref2; 0 <= _ref2 ? j++ : j--) {
          _results2.push(towerGrid[i][j] = false);
        }
        return _results2;
      }).call(this));
    }
    return _results;
  };

  Map.prototype.notLegalToDraw = function(xMouse, yMouse) {
    var active, index, line, name, path, _ref, _ref2;
    if (xMouse > gridsize.x || yMouse > gridsize.y) return true;
    _ref = Map.branchs;
    for (name in _ref) {
      path = _ref[name];
      active = path.activeWave;
      if (active <= activeWave) {
        _ref2 = path.lines;
        for (index in _ref2) {
          line = _ref2[index];
          if (xMouse >= line.x && xMouse <= line.x2 && yMouse >= line.y && yMouse <= line.y2) {
            return true;
            break;
          }
        }
      }
      return false;
    }
  };

  Map.prototype.checkSquare = function(locx, locy) {
    var xMouse, yMouse;
    yMouse = Math.floor(locy / 50);
    xMouse = Math.floor(locx / 50);
    if (!this.notLegalToDraw(xMouse, yMouse)) {
      towerGrid[xMouse][yMouse] = towerGrid[xMouse][yMouse] ? 0 : theColor;
    }
    return true;
  };

  Map.prototype.drawNextBranch = function(wave) {
    var active, color, index, line, name, path, _ref, _results;
    _ref = Map.branchs;
    _results = [];
    for (name in _ref) {
      path = _ref[name];
      color = path.color;
      active = path.activeWave;
      if (active <= wave) {
        _results.push((function() {
          var _ref2, _results2;
          _ref2 = path.lines;
          _results2 = [];
          for (index in _ref2) {
            line = _ref2[index];
            if (line.y !== line.y2) {
              _results2.push(g.setStrokeStyle(50).beginStroke(color).moveTo(line.x * 50 + 25, line.y * 50).lineTo(line.x2 * 50 + 25, line.y2 * 50 + 50));
            } else {
              _results2.push(g.setStrokeStyle(50).beginStroke(color).moveTo(line.x * 50, line.y * 50 + 25).lineTo(line.x2 * 50 + 50, line.y2 * 50 + 25));
            }
          }
          return _results2;
        })());
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Map.prototype.drawSquares = function() {
    var i, j, tg, _ref, _results;
    _results = [];
    for (i = 0, _ref = this.gridSize.x; 0 <= _ref ? i <= _ref : i >= _ref; 0 <= _ref ? i++ : i--) {
      _results.push((function() {
        var _ref2, _results2;
        _results2 = [];
        for (j = 0, _ref2 = this.gridSize.y; 0 <= _ref2 ? j <= _ref2 : j >= _ref2; 0 <= _ref2 ? j++ : j--) {
          tg = towerGrid[i][j];
          if (tg) {
            _results2.push(g.setStrokeStyle(1).beginStroke(tg).beginFill(tg).drawRect(i * 50 + 2, j * 50 + 2, 46, 46, 0));
          } else {
            _results2.push(void 0);
          }
        }
        return _results2;
      }).call(this));
    }
    return _results;
  };

  Map.prototype.drawEnemies = function() {
    return g.setStrokeStyle(1).beginStroke("black").beginFill("black").drawRoundRect(this.movingCube.x * 50, this.movingCube.y * 50 + 5, 40, 40, 0);
  };

  Map.prototype.enemyOcupation = function(thePath) {
    var diffx, diffy, n, newline, pathToFollow;
    pathToFollow = Map.branchs[thePath].lines;
    n = pathToFollow.length;
    this.movingCube.x += this.direction.x;
    this.movingCube.y += this.direction.y;
    if (this.movingCube.x < this.gridSize.x) {
      if ((this.movingCube.x >= pathToFollow[this.theLine].x2 - 0.01 && this.movingCube.x <= pathToFollow[this.theLine].x2 + 0.01 && this.direction.y === 0) || (this.movingCube.y >= pathToFollow[this.theLine].y2 - 0.01 && this.movingCube.y <= pathToFollow[this.theLine].y2 + 0.01 && this.direction.x === 0)) {
        this.theLine += 1;
        newline = pathToFollow[this.theLine];
        diffy = newline.y2 - newline.y;
        diffx = newline.x2 - newline.x;
        if (diffx === 0) {
          this.direction.x = 0;
        } else {
          this.direction.x = (diffx / Math.abs(diffx)) / 10;
        }
        if (diffy === 0) {
          return this.direction.y = 0;
        } else {
          return this.direction.y = (diffy / Math.abs(diffy)) / 10;
        }
      }
    } else {
      this.theLine = 0;
      this.movingCube.x = 0;
      return this.movingCube.y = 3;
    }
  };

  Map.prototype.tick = function() {
    this.drawGrid();
    this.drawNextBranch(activeWave);
    this.drawSquares();
    this.drawEnemies();
    return this.enemyOcupation("reallyWeirdBranch");
  };

  return Map;

})();
